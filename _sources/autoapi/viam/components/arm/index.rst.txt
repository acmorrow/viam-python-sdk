:py:mod:`viam.components.arm`
=============================

.. py:module:: viam.components.arm


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   arm/index.rst
   client/index.rst
   service/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.arm.Arm
   viam.components.arm.JointPositions
   viam.components.arm.Pose
   viam.components.arm.WorldState
   viam.components.arm.ArmClient




.. py:class:: Arm(name: str)



   Arm represents a physical robot arm that exists in three-dimensional space.

   This acts as an abstract base class for any drivers representing specific
   arm implementations. This cannot be used on its own. If the `__init__()` function is
   overriden, it must call the `super().__init__()` function.

   .. py:method:: get_end_position(self) -> viam.proto.api.common.Pose
      :abstractmethod:
      :async:

      Get the current position of the end of the arm expressed as a Pose.

      Returns: The location and orientation of the arm described as a Pose.


   .. py:method:: move_to_position(self, pose: viam.proto.api.common.Pose, world_state: Optional[viam.proto.api.common.WorldState] = None)
      :abstractmethod:
      :async:

      Move the end of the arm to the Pose specified in `pose`.
      When obstacles are specified in `world_state`, the motion plan of the arm will avoid them.

      :param pose: The destination Pose for the arm.
      :type pose: Pose
      :param world_state: The obstacles for the arm to avoid on its way to `pose`.
      :type world_state: WorldState


   .. py:method:: move_to_joint_positions(self, positions: viam.proto.api.component.arm.JointPositions)
      :abstractmethod:
      :async:

      Move each joint on the arm to the corresponding angle specified in `positions`.

      :param positions: The destination `JointPositions` for the arm.
      :type positions: JointPositions


   .. py:method:: get_joint_positions(self) -> viam.proto.api.component.arm.JointPositions
      :abstractmethod:
      :async:

      Get the JointPositions representing the current position of the arm.

      :returns: The current JointPositions for the arm.
      :rtype: JointPositions


   .. py:method:: stop(self)
      :abstractmethod:
      :async:

      Stop all motion of the arm. It is assumed that the arm stops immediately.



.. py:class:: JointPositions(*, degrees: Optional[Iterable[float]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: degrees(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[float]
      :property:

      A list of joint positions represented in degrees
      The numbers are ordered spatially from the base toward the end effector
      This is used in GetJointPositionsResponse and MoveToJointPositionsRequest



.. py:class:: Pose(*, x: float = ..., y: float = ..., z: float = ..., o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)



   Pose is a combination of location and orientation.
   Location is expressed as distance which is represented by x , y, z coordinates. Orientation is expressed as an orientation vector which
   is represented by o_x, o_y, o_z and theta. The o_x, o_y, o_z coordinates represent the point on the cartesian unit sphere that the end of
   the arm is pointing to (with the origin as reference). That unit vector forms an axis around which theta rotates. This means that
   incrementing / decrementing theta will perform an inline rotation of the end effector.
   Theta is defined as rotation between two planes: the first being defined by the origin, the point (0,0,1), and the rx, ry, rz point, and the
   second being defined by the origin, the rx, ry, rz point and the local Z axis. Therefore, if theta is kept at zero as the north/south pole
   is circled, the Roll will correct itself to remain in-line.

   .. py:attribute:: x
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: y
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: z
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: o_x
      :annotation: :float

      z component of a vector defining axis of rotation

   .. py:attribute:: o_y
      :annotation: :float

      x component of a vector defining axis of rotation

   .. py:attribute:: o_z
      :annotation: :float

      y component of a vector defining axis of rotation

   .. py:attribute:: theta
      :annotation: :float

      degrees


.. py:class:: WorldState(*, obstacles: Optional[Iterable[global___GeometriesInFrame]] = ..., transforms: Optional[Iterable[global___Transform]] = ...)



   WorldState contains information about the physical environment around a given robot. All of the fields within this message are optional,
   they can include information about the physical dimensions of an obstacle, the freespace of a robot, and any desired transforms between a
   given reference frame and a new target reference frame.

   .. py:method:: obstacles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GeometriesInFrame]
      :property:

      a list of obstacles expressed as a geomtry and the reference frame in which it was observed; this field is optional


   .. py:method:: transforms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Transform]
      :property:

      a list of Transforms needed to transform a pose from one reference frame to another; this field is optional



.. py:class:: ArmClient(name: str, channel: grpclib.client.Channel)



   gRPC client for an Arm component.

   Used to communicate with an existing `Arm` implementation over gRPC.

   .. py:method:: get_end_position(self) -> viam.proto.api.common.Pose
      :async:

      Get the current position of the end of the arm expressed as a Pose.

      Returns: The location and orientation of the arm described as a Pose.


   .. py:method:: move_to_position(self, pose: viam.proto.api.common.Pose, world_state: Optional[viam.proto.api.common.WorldState] = None)
      :async:

      Move the end of the arm to the Pose specified in `pose`.
      When obstacles are specified in `world_state`, the motion plan of the arm will avoid them.

      :param pose: The destination Pose for the arm.
      :type pose: Pose
      :param world_state: The obstacles for the arm to avoid on its way to `pose`.
      :type world_state: WorldState


   .. py:method:: get_joint_positions(self) -> viam.proto.api.component.arm.JointPositions
      :async:

      Get the JointPositions representing the current position of the arm.

      :returns: The current JointPositions for the arm.
      :rtype: JointPositions


   .. py:method:: move_to_joint_positions(self, positions: viam.proto.api.component.arm.JointPositions)
      :async:

      Move each joint on the arm to the corresponding angle specified in `positions`.

      :param positions: The destination `JointPositions` for the arm.
      :type positions: JointPositions


   .. py:method:: stop(self)
      :async:

      Stop all motion of the arm. It is assumed that the arm stops immediately.


   .. py:method:: do(self, command: Dict[str, Any]) -> Dict[str, Any]
      :async:

      Send/Receive arbitrary commands

      :param command: The command to execute
      :type command: Dict[str, Any]

      :raises NotImplementedError: Raised if the component does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Dict[str, Any]



