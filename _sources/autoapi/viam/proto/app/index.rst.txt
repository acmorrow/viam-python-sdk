:py:mod:`viam.proto.app`
========================

.. py:module:: viam.proto.app

.. autoapi-nested-parse::

   @generated by Viam.
   Do not edit manually!



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   data/index.rst
   datasync/index.rst
   model/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   robot/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.proto.app.AppServiceBase
   viam.proto.app.AppServiceStub
   viam.proto.app.DeleteRobotPartRequest
   viam.proto.app.DeleteRobotPartResponse
   viam.proto.app.DeleteRobotRequest
   viam.proto.app.DeleteRobotResponse
   viam.proto.app.FindRobotsRequest
   viam.proto.app.FindRobotsResponse
   viam.proto.app.Fragment
   viam.proto.app.GetRobotPartHistoryRequest
   viam.proto.app.GetRobotPartHistoryResponse
   viam.proto.app.GetRobotPartLogsRequest
   viam.proto.app.GetRobotPartLogsResponse
   viam.proto.app.GetRobotPartRequest
   viam.proto.app.GetRobotPartResponse
   viam.proto.app.GetRobotPartsRequest
   viam.proto.app.GetRobotPartsResponse
   viam.proto.app.GetRobotRequest
   viam.proto.app.GetRobotResponse
   viam.proto.app.ListLocationsRequest
   viam.proto.app.ListLocationsResponse
   viam.proto.app.ListOrganizationsRequest
   viam.proto.app.ListOrganizationsResponse
   viam.proto.app.Location
   viam.proto.app.LocationAuth
   viam.proto.app.LocationAuthRequest
   viam.proto.app.LocationAuthResponse
   viam.proto.app.LogEntry
   viam.proto.app.MarkPartAsMainRequest
   viam.proto.app.MarkPartAsMainResponse
   viam.proto.app.NewRobotPartRequest
   viam.proto.app.NewRobotPartResponse
   viam.proto.app.NewRobotRequest
   viam.proto.app.NewRobotResponse
   viam.proto.app.Organization
   viam.proto.app.Robot
   viam.proto.app.RobotPart
   viam.proto.app.RobotPartHistoryEntry
   viam.proto.app.TailRobotPartLogsRequest
   viam.proto.app.TailRobotPartLogsResponse
   viam.proto.app.UpdateRobotPartRequest
   viam.proto.app.UpdateRobotPartResponse
   viam.proto.app.UpdateRobotRequest
   viam.proto.app.UpdateRobotResponse




.. py:class:: AppServiceBase



   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: ListOrganizations(stream: grpclib.server.Stream[app.v1.app_pb2.ListOrganizationsRequest, app.v1.app_pb2.ListOrganizationsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: ListLocations(stream: grpclib.server.Stream[app.v1.app_pb2.ListLocationsRequest, app.v1.app_pb2.ListLocationsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: LocationAuth(stream: grpclib.server.Stream[app.v1.app_pb2.LocationAuthRequest, app.v1.app_pb2.LocationAuthResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetRobot(stream: grpclib.server.Stream[app.v1.app_pb2.GetRobotRequest, app.v1.app_pb2.GetRobotResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetRobotParts(stream: grpclib.server.Stream[app.v1.app_pb2.GetRobotPartsRequest, app.v1.app_pb2.GetRobotPartsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetRobotPart(stream: grpclib.server.Stream[app.v1.app_pb2.GetRobotPartRequest, app.v1.app_pb2.GetRobotPartResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetRobotPartLogs(stream: grpclib.server.Stream[app.v1.app_pb2.GetRobotPartLogsRequest, app.v1.app_pb2.GetRobotPartLogsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: TailRobotPartLogs(stream: grpclib.server.Stream[app.v1.app_pb2.TailRobotPartLogsRequest, app.v1.app_pb2.TailRobotPartLogsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetRobotPartHistory(stream: grpclib.server.Stream[app.v1.app_pb2.GetRobotPartHistoryRequest, app.v1.app_pb2.GetRobotPartHistoryResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: UpdateRobotPart(stream: grpclib.server.Stream[app.v1.app_pb2.UpdateRobotPartRequest, app.v1.app_pb2.UpdateRobotPartResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: NewRobotPart(stream: grpclib.server.Stream[app.v1.app_pb2.NewRobotPartRequest, app.v1.app_pb2.NewRobotPartResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: DeleteRobotPart(stream: grpclib.server.Stream[app.v1.app_pb2.DeleteRobotPartRequest, app.v1.app_pb2.DeleteRobotPartResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: MarkPartAsMain(stream: grpclib.server.Stream[app.v1.app_pb2.MarkPartAsMainRequest, app.v1.app_pb2.MarkPartAsMainResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: FindRobots(stream: grpclib.server.Stream[app.v1.app_pb2.FindRobotsRequest, app.v1.app_pb2.FindRobotsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: NewRobot(stream: grpclib.server.Stream[app.v1.app_pb2.NewRobotRequest, app.v1.app_pb2.NewRobotResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: UpdateRobot(stream: grpclib.server.Stream[app.v1.app_pb2.UpdateRobotRequest, app.v1.app_pb2.UpdateRobotResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: DeleteRobot(stream: grpclib.server.Stream[app.v1.app_pb2.DeleteRobotRequest, app.v1.app_pb2.DeleteRobotResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]



.. py:class:: AppServiceStub(channel: grpclib.client.Channel)


.. py:class:: DeleteRobotPartRequest(*, part_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: part_id
      :annotation: :str

      


.. py:class:: DeleteRobotPartResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: DeleteRobotRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      


.. py:class:: DeleteRobotResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: FindRobotsRequest(*, location_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: location_id
      :annotation: :str

      


.. py:class:: FindRobotsResponse(*, robots: collections.abc.Iterable[global___Robot] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: robots() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Robot]
      :property:



.. py:class:: Fragment(*, id: str = ..., name: str = ..., fragment: google.protobuf.struct_pb2.Struct | None = ..., organization_owner: str = ..., public: bool = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: organization_owner
      :annotation: :str

      

   .. py:attribute:: public
      :annotation: :bool

      

   .. py:method:: fragment() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[fragment, b'fragment']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetRobotPartHistoryRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      


.. py:class:: GetRobotPartHistoryResponse(*, history: collections.abc.Iterable[global___RobotPartHistoryEntry] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: history() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotPartHistoryEntry]
      :property:



.. py:class:: GetRobotPartLogsRequest(*, id: str = ..., errors_only: bool = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: errors_only
      :annotation: :bool

      


.. py:class:: GetRobotPartLogsResponse(*, logs: collections.abc.Iterable[global___LogEntry] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: logs() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogEntry]
      :property:



.. py:class:: GetRobotPartRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      


.. py:class:: GetRobotPartResponse(*, part: global___RobotPart | None = ..., config_json: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: config_json
      :annotation: :str

      

   .. py:method:: part() -> global___RobotPart
      :property:


   .. py:method:: HasField(field_name: Literal[part, b'part']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetRobotPartsRequest(*, robot_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: robot_id
      :annotation: :str

      


.. py:class:: GetRobotPartsResponse(*, parts: collections.abc.Iterable[global___RobotPart] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: parts() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotPart]
      :property:



.. py:class:: GetRobotRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      


.. py:class:: GetRobotResponse(*, robot: global___Robot | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: robot() -> global___Robot
      :property:


   .. py:method:: HasField(field_name: Literal[robot, b'robot']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ListLocationsRequest(*, organization_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: organization_id
      :annotation: :str

      


.. py:class:: ListLocationsResponse(*, locations: collections.abc.Iterable[global___Location] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: locations() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Location]
      :property:



.. py:class:: ListOrganizationsRequest



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ListOrganizationsResponse(*, organizations: collections.abc.Iterable[global___Organization] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: organizations() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Organization]
      :property:



.. py:class:: Location(*, id: str = ..., name: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      


.. py:class:: LocationAuth(*, secret: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: secret
      :annotation: :str

      


.. py:class:: LocationAuthRequest(*, location_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: location_id
      :annotation: :str

      


.. py:class:: LocationAuthResponse(*, auth: global___LocationAuth | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: auth() -> global___LocationAuth
      :property:


   .. py:method:: HasField(field_name: Literal[auth, b'auth']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: LogEntry(*, host: str = ..., level: str = ..., time: google.protobuf.timestamp_pb2.Timestamp | None = ..., logger_name: str = ..., message: str = ..., caller: google.protobuf.struct_pb2.Struct | None = ..., stack: str = ..., fields: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: host
      :annotation: :str

      

   .. py:attribute:: level
      :annotation: :str

      

   .. py:attribute:: logger_name
      :annotation: :str

      

   .. py:attribute:: message
      :annotation: :str

      

   .. py:attribute:: stack
      :annotation: :str

      

   .. py:method:: time() -> google.protobuf.timestamp_pb2.Timestamp
      :property:


   .. py:method:: caller() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: fields() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]
      :property:


   .. py:method:: HasField(field_name: Literal[caller, b'caller', time, b'time']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: MarkPartAsMainRequest(*, part_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: part_id
      :annotation: :str

      


.. py:class:: MarkPartAsMainResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: NewRobotPartRequest(*, robot_id: str = ..., part_name: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: robot_id
      :annotation: :str

      

   .. py:attribute:: part_name
      :annotation: :str

      


.. py:class:: NewRobotPartResponse(*, part_id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: part_id
      :annotation: :str

      


.. py:class:: NewRobotRequest(*, name: str = ..., location: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: location
      :annotation: :str

      


.. py:class:: NewRobotResponse(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      


.. py:class:: Organization(*, id: str = ..., name: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      


.. py:class:: Robot(*, id: str = ..., name: str = ..., location: str = ..., last_access: google.protobuf.timestamp_pb2.Timestamp | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: location
      :annotation: :str

      

   .. py:method:: last_access() -> google.protobuf.timestamp_pb2.Timestamp
      :property:


   .. py:method:: HasField(field_name: Literal[last_access, b'last_access']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RobotPart(*, id: str = ..., name: str = ..., dns_name: str = ..., secret: str = ..., robot: str = ..., location_id: str = ..., robot_config: google.protobuf.struct_pb2.Struct | None = ..., last_access: google.protobuf.timestamp_pb2.Timestamp | None = ..., user_supplied_info: google.protobuf.struct_pb2.Struct | None = ..., main_part: bool = ..., fqdn: str = ..., local_fqdn: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: dns_name
      :annotation: :str

      dns_name part name used for fqdn and local fqdn. Anytime the Name is updated this should be sanitized and updated as well.

   .. py:attribute:: secret
      :annotation: :str

      

   .. py:attribute:: robot
      :annotation: :str

      

   .. py:attribute:: location_id
      :annotation: :str

      Store the location_id to allow for unique indexes across parts and locations. This filed MUST be updated each time the robots location
      changes.

   .. py:attribute:: main_part
      :annotation: :bool

      

   .. py:attribute:: fqdn
      :annotation: :str

      

   .. py:attribute:: local_fqdn
      :annotation: :str

      

   .. py:method:: robot_config() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: last_access() -> google.protobuf.timestamp_pb2.Timestamp
      :property:


   .. py:method:: user_supplied_info() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[last_access, b'last_access', robot_config, b'robot_config', user_supplied_info, b'user_supplied_info']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RobotPartHistoryEntry(*, part: str = ..., robot: str = ..., when: google.protobuf.timestamp_pb2.Timestamp | None = ..., old: global___RobotPart | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: part
      :annotation: :str

      

   .. py:attribute:: robot
      :annotation: :str

      

   .. py:method:: when() -> google.protobuf.timestamp_pb2.Timestamp
      :property:


   .. py:method:: old() -> global___RobotPart
      :property:


   .. py:method:: HasField(field_name: Literal[old, b'old', when, b'when']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TailRobotPartLogsRequest(*, id: str = ..., errors_only: bool = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: errors_only
      :annotation: :bool

      


.. py:class:: TailRobotPartLogsResponse(*, logs: collections.abc.Iterable[global___LogEntry] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: logs() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogEntry]
      :property:



.. py:class:: UpdateRobotPartRequest(*, id: str = ..., name: str = ..., robot_config: google.protobuf.struct_pb2.Struct | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:method:: robot_config() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[robot_config, b'robot_config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateRobotPartResponse(*, part: global___RobotPart | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: part() -> global___RobotPart
      :property:


   .. py:method:: HasField(field_name: Literal[part, b'part']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateRobotRequest(*, id: str = ..., name: str = ..., location: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: location
      :annotation: :str

      


.. py:class:: UpdateRobotResponse(*, robot: global___Robot | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: robot() -> global___Robot
      :property:


   .. py:method:: HasField(field_name: Literal[robot, b'robot']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



