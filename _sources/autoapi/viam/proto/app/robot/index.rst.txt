:py:mod:`viam.proto.app.robot`
==============================

.. py:module:: viam.proto.app.robot

.. autoapi-nested-parse::

   @generated by Viam.
   Do not edit manually!



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.proto.app.robot.RobotServiceBase
   viam.proto.app.robot.RobotServiceStub
   viam.proto.app.robot.AgentInfo
   viam.proto.app.robot.AuthConfig
   viam.proto.app.robot.AuthHandlerConfig
   viam.proto.app.robot.CertificateRequest
   viam.proto.app.robot.CertificateResponse
   viam.proto.app.robot.CloudConfig
   viam.proto.app.robot.ComponentConfig
   viam.proto.app.robot.ConfigRequest
   viam.proto.app.robot.ConfigResponse
   viam.proto.app.robot.Frame
   viam.proto.app.robot.LogRequest
   viam.proto.app.robot.LogResponse
   viam.proto.app.robot.NeedsRestartRequest
   viam.proto.app.robot.NeedsRestartResponse
   viam.proto.app.robot.NetworkConfig
   viam.proto.app.robot.Orientation
   viam.proto.app.robot.ProcessConfig
   viam.proto.app.robot.RemoteAuth
   viam.proto.app.robot.RemoteConfig
   viam.proto.app.robot.ResourceLevelServiceConfig
   viam.proto.app.robot.RobotConfig
   viam.proto.app.robot.ServiceConfig
   viam.proto.app.robot.Translation




.. py:class:: RobotServiceBase



   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: Config(stream: grpclib.server.Stream[app.v1.robot_pb2.ConfigRequest, app.v1.robot_pb2.ConfigResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: Certificate(stream: grpclib.server.Stream[app.v1.robot_pb2.CertificateRequest, app.v1.robot_pb2.CertificateResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: Log(stream: grpclib.server.Stream[app.v1.robot_pb2.LogRequest, app.v1.robot_pb2.LogResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: NeedsRestart(stream: grpclib.server.Stream[app.v1.robot_pb2.NeedsRestartRequest, app.v1.robot_pb2.NeedsRestartResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]



.. py:class:: RobotServiceStub(channel: grpclib.client.Channel)


.. py:class:: AgentInfo(*, host: str = ..., os: str = ..., ips: collections.abc.Iterable[builtins.str] | None = ..., version: str = ..., git_revision: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: host
      :annotation: :str

      

   .. py:attribute:: os
      :annotation: :str

      

   .. py:attribute:: version
      :annotation: :str

      RDK version

   .. py:attribute:: git_revision
      :annotation: :str

      

   .. py:method:: ips() -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]
      :property:

      list of all ipv4 ips.



.. py:class:: AuthConfig(*, handlers: collections.abc.Iterable[global___AuthHandlerConfig] | None = ..., tls_auth_entities: collections.abc.Iterable[builtins.str] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: handlers() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AuthHandlerConfig]
      :property:


   .. py:method:: tls_auth_entities() -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]
      :property:



.. py:class:: AuthHandlerConfig(*, type: global___CredentialsType = ..., config: google.protobuf.struct_pb2.Struct | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: type
      :annotation: :global___CredentialsType

      

   .. py:method:: config() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[config, b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CertificateRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.


.. py:class:: CertificateResponse(*, id: str = ..., tls_certificate: str = ..., tls_private_key: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.

   .. py:attribute:: tls_certificate
      :annotation: :str

      

   .. py:attribute:: tls_private_key
      :annotation: :str

      


.. py:class:: CloudConfig(*, id: str = ..., fqdn: str = ..., local_fqdn: str = ..., managed_by: str = ..., signaling_address: str = ..., signaling_insecure: bool = ..., location_secret: str = ..., secret: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.

   .. py:attribute:: fqdn
      :annotation: :str

      

   .. py:attribute:: local_fqdn
      :annotation: :str

      

   .. py:attribute:: managed_by
      :annotation: :str

      

   .. py:attribute:: signaling_address
      :annotation: :str

      

   .. py:attribute:: signaling_insecure
      :annotation: :bool

      

   .. py:attribute:: location_secret
      :annotation: :str

      

   .. py:attribute:: secret
      :annotation: :str

      


.. py:class:: ComponentConfig(*, name: str = ..., namespace: str = ..., type: str = ..., model: str = ..., frame: global___Frame | None = ..., depends_on: collections.abc.Iterable[builtins.str] | None = ..., service_configs: collections.abc.Iterable[global___ResourceLevelServiceConfig] | None = ..., attributes: google.protobuf.struct_pb2.Struct | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: namespace
      :annotation: :str

      

   .. py:attribute:: type
      :annotation: :str

      

   .. py:attribute:: model
      :annotation: :str

      

   .. py:method:: frame() -> global___Frame
      :property:


   .. py:method:: depends_on() -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]
      :property:


   .. py:method:: service_configs() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResourceLevelServiceConfig]
      :property:


   .. py:method:: attributes() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[attributes, b'attributes', frame, b'frame']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ConfigRequest(*, id: str = ..., agent_info: global___AgentInfo | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.

   .. py:method:: agent_info() -> global___AgentInfo
      :property:

      Details about the RDK (os, version) are updated during this request.


   .. py:method:: HasField(field_name: Literal[_agent_info, b'_agent_info', agent_info, b'agent_info']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: Literal[_agent_info, b'_agent_info']) -> typing_extensions.Literal['agent_info'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ConfigResponse(*, config: global___RobotConfig | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: config() -> global___RobotConfig
      :property:


   .. py:method:: HasField(field_name: Literal[config, b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Frame(*, parent: str = ..., translation: global___Translation | None = ..., orientation: global___Orientation | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: parent
      :annotation: :str

      

   .. py:method:: translation() -> global___Translation
      :property:


   .. py:method:: orientation() -> global___Orientation
      :property:


   .. py:method:: HasField(field_name: Literal[orientation, b'orientation', translation, b'translation']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: LogRequest(*, id: str = ..., logs: collections.abc.Iterable[app.v1.app_pb2.LogEntry] | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.

   .. py:method:: logs() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.app.v1.app_pb2.LogEntry]
      :property:



.. py:class:: LogResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: NeedsRestartRequest(*, id: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.


.. py:class:: NeedsRestartResponse(*, id: str = ..., must_restart: bool = ..., restart_check_interval: google.protobuf.duration_pb2.Duration | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: id
      :annotation: :str

      Robot part id.

   .. py:attribute:: must_restart
      :annotation: :bool

      

   .. py:method:: restart_check_interval() -> google.protobuf.duration_pb2.Duration
      :property:


   .. py:method:: HasField(field_name: Literal[restart_check_interval, b'restart_check_interval']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: NetworkConfig(*, fqdn: str = ..., bind_address: str = ..., tls_cert_file: str = ..., tls_key_file: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: fqdn
      :annotation: :str

      

   .. py:attribute:: bind_address
      :annotation: :str

      

   .. py:attribute:: tls_cert_file
      :annotation: :str

      

   .. py:attribute:: tls_key_file
      :annotation: :str

      


.. py:class:: Orientation(*, no_orientation: global___Orientation.NoOrientation | None = ..., vector_radians: global___Orientation.OrientationVectorRadians | None = ..., vector_degrees: global___Orientation.OrientationVectorDegrees | None = ..., euler_angles: global___Orientation.EulerAngles | None = ..., axis_angles: global___Orientation.AxisAngles | None = ..., quaternion: global___Orientation.Quaternion | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:class:: NoOrientation



      Abstract base class for protocol messages.

      Protocol message classes are almost always generated by the protocol
      compiler.  These generated types subclass Message and implement the methods
      shown below.


   .. py:class:: OrientationVectorRadians(*, theta: float = ..., x: float = ..., y: float = ..., z: float = ...)



      OrientationVector containing ox, oy, oz, theta represents an orientation vector
      Structured similarly to an angle axis, an orientation vector works differently. Rather than representing an orientation
      with an arbitrary axis and a rotation around it from an origin, an orientation vector represents orientation
      such that the ox/oy/oz components represent the point on the cartesian unit sphere at which your end effector is pointing
      from the origin, and that unit vector forms an axis around which theta rotates. This means that incrementing/decrementing
      theta will perform an in-line rotation of the end effector.
      Theta is defined as rotation between two planes: the plane defined by the origin, the point (0,0,1), and the rx,ry,rz
      point, and the plane defined by the origin, the rx,ry,rz point, and the new local Z axis. So if theta is kept at
      zero as the north/south pole is circled, the Roll will correct itself to remain in-line.

      .. py:attribute:: theta
         :annotation: :float

         

      .. py:attribute:: x
         :annotation: :float

         

      .. py:attribute:: y
         :annotation: :float

         

      .. py:attribute:: z
         :annotation: :float

         


   .. py:class:: OrientationVectorDegrees(*, theta: float = ..., x: float = ..., y: float = ..., z: float = ...)



      OrientationVectorDegrees is the orientation vector between two objects, but expressed in degrees rather than radians.
      Because protobuf Pose is in degrees, this is necessary.

      .. py:attribute:: theta
         :annotation: :float

         

      .. py:attribute:: x
         :annotation: :float

         

      .. py:attribute:: y
         :annotation: :float

         

      .. py:attribute:: z
         :annotation: :float

         


   .. py:class:: EulerAngles(*, roll: float = ..., pitch: float = ..., yaw: float = ...)



      EulerAngles are three angles (in radians) used to represent the rotation of an object in 3D Euclidean space
      The Tait–Bryan angle formalism is used, with rotations around three distinct axes in the z-y′-x″ sequence.

      .. py:attribute:: roll
         :annotation: :float

         

      .. py:attribute:: pitch
         :annotation: :float

         

      .. py:attribute:: yaw
         :annotation: :float

         


   .. py:class:: AxisAngles(*, theta: float = ..., x: float = ..., y: float = ..., z: float = ...)



      See here for a thorough explanation: https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation
      Basic explanation: Imagine a 3d cartesian grid centered at 0,0,0, and a sphere of radius 1 centered at
      that same point. An orientation can be expressed by first specifying an axis, i.e. a line from the origin
      to a point on that sphere, represented by (rx, ry, rz), and a rotation around that axis, theta.
      These four numbers can be used as-is (R4), or they can be converted to R3, where theta is multiplied by each of
      the unit sphere components to give a vector whose length is theta and whose direction is the original axis.
      AxisAngles represents an R4 axis angle.

      .. py:attribute:: theta
         :annotation: :float

         

      .. py:attribute:: x
         :annotation: :float

         

      .. py:attribute:: y
         :annotation: :float

         

      .. py:attribute:: z
         :annotation: :float

         


   .. py:class:: Quaternion(*, w: float = ..., x: float = ..., y: float = ..., z: float = ...)



      Quaternion is a float64 precision quaternion.

      .. py:attribute:: w
         :annotation: :float

         

      .. py:attribute:: x
         :annotation: :float

         

      .. py:attribute:: y
         :annotation: :float

         

      .. py:attribute:: z
         :annotation: :float

         


   .. py:method:: no_orientation() -> global___Orientation
      :property:


   .. py:method:: vector_radians() -> global___Orientation
      :property:


   .. py:method:: vector_degrees() -> global___Orientation
      :property:


   .. py:method:: euler_angles() -> global___Orientation
      :property:


   .. py:method:: axis_angles() -> global___Orientation
      :property:


   .. py:method:: quaternion() -> global___Orientation
      :property:


   .. py:method:: HasField(field_name: Literal[axis_angles, b'axis_angles', euler_angles, b'euler_angles', no_orientation, b'no_orientation', quaternion, b'quaternion', type, b'type', vector_degrees, b'vector_degrees', vector_radians, b'vector_radians']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: Literal[type, b'type']) -> typing_extensions.Literal['no_orientation', 'vector_radians', 'vector_degrees', 'euler_angles', 'axis_angles', 'quaternion'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ProcessConfig(*, id: str = ..., name: str = ..., args: collections.abc.Iterable[builtins.str] | None = ..., cwd: str = ..., one_shot: bool = ..., log: bool = ...)



   A ProcessConfig describes how to manage a system process.

   .. py:attribute:: id
      :annotation: :str

      

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: cwd
      :annotation: :str

      

   .. py:attribute:: one_shot
      :annotation: :bool

      

   .. py:attribute:: log
      :annotation: :bool

      

   .. py:method:: args() -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]
      :property:



.. py:class:: RemoteAuth(*, credentials: global___RemoteAuth.Credentials | None = ..., entity: str = ...)



   RemoteAuth specifies how to authenticate against a remote. If no credentials are
   specified, authentication does not happen. If an entity is specified, the
   authentication request will specify it.

   .. py:class:: Credentials(*, type: global___CredentialsType = ..., payload: str = ...)



      Credentials packages up both a type of credential along with its payload which
      is formatted specific to the type.

      .. py:attribute:: type
         :annotation: :global___CredentialsType

         

      .. py:attribute:: payload
         :annotation: :str

         


   .. py:attribute:: entity
      :annotation: :str

      

   .. py:method:: credentials() -> global___RemoteAuth
      :property:


   .. py:method:: HasField(field_name: Literal[credentials, b'credentials']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RemoteConfig(*, name: str = ..., address: str = ..., frame: global___Frame | None = ..., auth: global___RemoteAuth | None = ..., managed_by: str = ..., insecure: bool = ..., connection_check_interval: google.protobuf.duration_pb2.Duration | None = ..., reconnect_interval: google.protobuf.duration_pb2.Duration | None = ..., service_configs: collections.abc.Iterable[global___ResourceLevelServiceConfig] | None = ..., secret: str = ...)



   A RemoteConfig describes a remote robot that should be integrated.
   The Frame field defines how the "world" node of the remote robot should be reconciled with the "world" node of the
   the current robot. All components of the remote robot who have Parent as "world" will be attached to the parent defined
   in Frame, and with the given offset as well.

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: address
      :annotation: :str

      

   .. py:attribute:: managed_by
      :annotation: :str

      

   .. py:attribute:: insecure
      :annotation: :bool

      

   .. py:attribute:: secret
      :annotation: :str

      Secret is a helper for a robot location secret.

   .. py:method:: frame() -> global___Frame
      :property:


   .. py:method:: auth() -> global___RemoteAuth
      :property:


   .. py:method:: connection_check_interval() -> google.protobuf.duration_pb2.Duration
      :property:


   .. py:method:: reconnect_interval() -> google.protobuf.duration_pb2.Duration
      :property:


   .. py:method:: service_configs() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResourceLevelServiceConfig]
      :property:


   .. py:method:: HasField(field_name: Literal[auth, b'auth', connection_check_interval, b'connection_check_interval', frame, b'frame', reconnect_interval, b'reconnect_interval']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceLevelServiceConfig(*, type: str = ..., attributes: google.protobuf.struct_pb2.Struct | None = ...)



   A ResourceLevelServiceConfig describes component or remote configuration for a service.

   .. py:attribute:: type
      :annotation: :str

      

   .. py:method:: attributes() -> google.protobuf.struct_pb2.Struct
      :property:

      TODO(adam): Should this be move to a structured type as defined in the typescript frontend.


   .. py:method:: HasField(field_name: Literal[attributes, b'attributes']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RobotConfig(*, cloud: global___CloudConfig | None = ..., remotes: collections.abc.Iterable[global___RemoteConfig] | None = ..., components: collections.abc.Iterable[global___ComponentConfig] | None = ..., processes: collections.abc.Iterable[global___ProcessConfig] | None = ..., services: collections.abc.Iterable[global___ServiceConfig] | None = ..., network: global___NetworkConfig | None = ..., auth: global___AuthConfig | None = ..., debug: builtins.bool | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: debug
      :annotation: :bool

      Turns on debug mode for robot, adding an echo server and more logging and tracing. Only works after restart

   .. py:method:: cloud() -> global___CloudConfig
      :property:


   .. py:method:: remotes() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RemoteConfig]
      :property:


   .. py:method:: components() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComponentConfig]
      :property:


   .. py:method:: processes() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ProcessConfig]
      :property:


   .. py:method:: services() -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServiceConfig]
      :property:


   .. py:method:: network() -> global___NetworkConfig
      :property:


   .. py:method:: auth() -> global___AuthConfig
      :property:


   .. py:method:: HasField(field_name: Literal[_auth, b'_auth', _debug, b'_debug', _network, b'_network', auth, b'auth', cloud, b'cloud', debug, b'debug', network, b'network']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: Literal[_auth, b'_auth']) -> typing_extensions.Literal['auth'] | None
               WhichOneof(oneof_group: Literal[_debug, b'_debug']) -> typing_extensions.Literal['debug'] | None
               WhichOneof(oneof_group: Literal[_network, b'_network']) -> typing_extensions.Literal['network'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ServiceConfig(*, name: str = ..., namespace: str = ..., type: str = ..., attributes: google.protobuf.struct_pb2.Struct | None = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: namespace
      :annotation: :str

      

   .. py:attribute:: type
      :annotation: :str

      

   .. py:method:: attributes() -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(field_name: Literal[attributes, b'attributes']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Translation(*, x: float = ..., y: float = ..., z: float = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: x
      :annotation: :float

      

   .. py:attribute:: y
      :annotation: :float

      

   .. py:attribute:: z
      :annotation: :float

      


