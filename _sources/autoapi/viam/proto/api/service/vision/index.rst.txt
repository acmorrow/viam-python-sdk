:py:mod:`viam.proto.api.service.vision`
=======================================

.. py:module:: viam.proto.api.service.vision

.. autoapi-nested-parse::

   @generated by Viam.
   Do not edit manually!



Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.proto.api.service.vision.VisionServiceBase
   viam.proto.api.service.vision.VisionServiceStub
   viam.proto.api.service.vision.AddDetectorRequest
   viam.proto.api.service.vision.AddDetectorResponse
   viam.proto.api.service.vision.Detection
   viam.proto.api.service.vision.GetDetectionsRequest
   viam.proto.api.service.vision.GetDetectionsResponse
   viam.proto.api.service.vision.GetDetectorNamesRequest
   viam.proto.api.service.vision.GetDetectorNamesResponse
   viam.proto.api.service.vision.GetObjectPointCloudsRequest
   viam.proto.api.service.vision.GetObjectPointCloudsResponse
   viam.proto.api.service.vision.GetSegmenterNamesRequest
   viam.proto.api.service.vision.GetSegmenterNamesResponse
   viam.proto.api.service.vision.GetSegmenterParametersRequest
   viam.proto.api.service.vision.GetSegmenterParametersResponse
   viam.proto.api.service.vision.TypedParameter




.. py:class:: VisionServiceBase



   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: GetDetectorNames(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.GetDetectorNamesRequest, proto.api.service.vision.v1.vision_pb2.GetDetectorNamesResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: AddDetector(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.AddDetectorRequest, proto.api.service.vision.v1.vision_pb2.AddDetectorResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetDetections(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.GetDetectionsRequest, proto.api.service.vision.v1.vision_pb2.GetDetectionsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetSegmenterNames(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.GetSegmenterNamesRequest, proto.api.service.vision.v1.vision_pb2.GetSegmenterNamesResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetSegmenterParameters(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.GetSegmenterParametersRequest, proto.api.service.vision.v1.vision_pb2.GetSegmenterParametersResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetObjectPointClouds(self, stream: grpclib.server.Stream[proto.api.service.vision.v1.vision_pb2.GetObjectPointCloudsRequest, proto.api.service.vision.v1.vision_pb2.GetObjectPointCloudsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: __mapping__(self) -> Dict[str, grpclib.const.Handler]



.. py:class:: VisionServiceStub(channel: grpclib.client.Channel)


.. py:class:: AddDetectorRequest(*, detector_name: Text = ..., detector_model_type: Text = ..., detector_parameters: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: detector_name
      :annotation: :Text

      

   .. py:attribute:: detector_model_type
      :annotation: :Text

      

   .. py:method:: detector_parameters(self) -> google.protobuf.struct_pb2.Struct
      :property:


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[detector_parameters, b'detector_parameters']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddDetectorResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: Detection(*, x_min: Optional[int] = ..., y_min: Optional[int] = ..., x_max: Optional[int] = ..., y_max: Optional[int] = ..., confidence: float = ..., class_name: Text = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: x_min
      :annotation: :int

      the four corners of the box

   .. py:attribute:: y_min
      :annotation: :int

      

   .. py:attribute:: x_max
      :annotation: :int

      

   .. py:attribute:: y_max
      :annotation: :int

      

   .. py:attribute:: confidence
      :annotation: :float

      the confidence of the detection

   .. py:attribute:: class_name
      :annotation: :Text

      label associated with the detected object

   .. py:method:: HasField(self, field_name: typing_extensions.Literal[_x_max, b'_x_max', _x_min, b'_x_min', _y_max, b'_y_max', _y_min, b'_y_min', x_max, b'x_max', x_min, b'x_min', y_max, b'y_max', y_min, b'y_min']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(self, oneof_group: typing_extensions.Literal[_x_max, b'_x_max']) -> Optional[typing_extensions.Literal[x_max]]
               WhichOneof(self, oneof_group: typing_extensions.Literal[_x_min, b'_x_min']) -> Optional[typing_extensions.Literal[x_min]]
               WhichOneof(self, oneof_group: typing_extensions.Literal[_y_max, b'_y_max']) -> Optional[typing_extensions.Literal[y_max]]
               WhichOneof(self, oneof_group: typing_extensions.Literal[_y_min, b'_y_min']) -> Optional[typing_extensions.Literal[y_min]]

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetDetectionsRequest(*, camera_name: Text = ..., detector_name: Text = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: camera_name
      :annotation: :Text

      name of camera source to use as input

   .. py:attribute:: detector_name
      :annotation: :Text

      name of the registered detector to use


.. py:class:: GetDetectionsResponse(*, detections: Optional[Iterable[global___Detection]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: detections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Detection]
      :property:

      the bounding boxes and labels



.. py:class:: GetDetectorNamesRequest



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: GetDetectorNamesResponse(*, detector_names: Optional[Iterable[Text]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: detector_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[Text]
      :property:

      detectors in the registry



.. py:class:: GetObjectPointCloudsRequest(*, camera_name: Text = ..., segmenter_name: Text = ..., mime_type: Text = ..., parameters: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: camera_name
      :annotation: :Text

      Name of a camera

   .. py:attribute:: segmenter_name
      :annotation: :Text

      Name of the segmentation algorithm

   .. py:attribute:: mime_type
      :annotation: :Text

      Requested MIME type of response

   .. py:method:: parameters(self) -> google.protobuf.struct_pb2.Struct
      :property:

      parameters for the chosen segmenter


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[parameters, b'parameters']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetObjectPointCloudsResponse(*, mime_type: Text = ..., objects: Optional[Iterable[viam.gen.proto.api.common.v1.common_pb2.PointCloudObject]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: mime_type
      :annotation: :Text

      Actual MIME type of response

   .. py:method:: objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.proto.api.common.v1.common_pb2.PointCloudObject]
      :property:

      List of objects in the scene



.. py:class:: GetSegmenterNamesRequest



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: GetSegmenterNamesResponse(*, segmenter_names: Optional[Iterable[Text]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: segmenter_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[Text]
      :property:

      segmenters in the registry



.. py:class:: GetSegmenterParametersRequest(*, segmenter_name: Text = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: segmenter_name
      :annotation: :Text

      Name of the segmentation algo


.. py:class:: GetSegmenterParametersResponse(*, segmenter_parameters: Optional[Iterable[global___TypedParameter]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: segmenter_parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TypedParameter]
      :property:

      parameter names of the segmenter in the request



.. py:class:: TypedParameter(*, name: Text = ..., type: Text = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      

   .. py:attribute:: type
      :annotation: :Text

      


