:py:mod:`viam.proto.api.common`
===============================

.. py:module:: viam.proto.api.common

.. autoapi-nested-parse::

   @generated by Viam.
   Do not edit manually!



Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.proto.api.common.AnalogStatus
   viam.proto.api.common.BoardStatus
   viam.proto.api.common.DigitalInterruptStatus
   viam.proto.api.common.GeoPoint
   viam.proto.api.common.GeometriesInFrame
   viam.proto.api.common.Geometry
   viam.proto.api.common.PointCloudObject
   viam.proto.api.common.Pose
   viam.proto.api.common.PoseInFrame
   viam.proto.api.common.RectangularPrism
   viam.proto.api.common.ResourceName
   viam.proto.api.common.Sphere
   viam.proto.api.common.Transform
   viam.proto.api.common.Vector3
   viam.proto.api.common.WorldState




.. py:class:: AnalogStatus(*, value: int = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: value
      :annotation: :int

      Current value of the analog reader of a robot's board


.. py:class:: BoardStatus(*, analogs: Optional[Mapping[Text, global___AnalogStatus]] = ..., digital_interrupts: Optional[Mapping[Text, global___DigitalInterruptStatus]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:class:: AnalogsEntry(*, key: Text = ..., value: Optional[global___AnalogStatus] = ...)



      Abstract base class for protocol messages.

      Protocol message classes are almost always generated by the protocol
      compiler.  These generated types subclass Message and implement the methods
      shown below.

      .. py:attribute:: key
         :annotation: :Text

         

      .. py:method:: value(self) -> global___AnalogStatus
         :property:


      .. py:method:: HasField(self, field_name: typing_extensions.Literal[value, b'value']) -> bool

         Checks if a certain field is set for the message.

         For a oneof group, checks if any field inside is set. Note that if the
         field_name is not defined in the message descriptor, :exc:`ValueError` will
         be raised.

         :param field_name: The name of the field to check for presence.
         :type field_name: str

         :returns: Whether a value has been set for the named field.
         :rtype: bool

         :raises ValueError: if the `field_name` is not a member of this message.



   .. py:class:: DigitalInterruptsEntry(*, key: Text = ..., value: Optional[global___DigitalInterruptStatus] = ...)



      Abstract base class for protocol messages.

      Protocol message classes are almost always generated by the protocol
      compiler.  These generated types subclass Message and implement the methods
      shown below.

      .. py:attribute:: key
         :annotation: :Text

         

      .. py:method:: value(self) -> global___DigitalInterruptStatus
         :property:


      .. py:method:: HasField(self, field_name: typing_extensions.Literal[value, b'value']) -> bool

         Checks if a certain field is set for the message.

         For a oneof group, checks if any field inside is set. Note that if the
         field_name is not defined in the message descriptor, :exc:`ValueError` will
         be raised.

         :param field_name: The name of the field to check for presence.
         :type field_name: str

         :returns: Whether a value has been set for the named field.
         :rtype: bool

         :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: analogs(self) -> google.protobuf.internal.containers.MessageMap[Text, global___AnalogStatus]
      :property:


   .. py:method:: digital_interrupts(self) -> google.protobuf.internal.containers.MessageMap[Text, global___DigitalInterruptStatus]
      :property:



.. py:class:: DigitalInterruptStatus(*, value: int = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: value
      :annotation: :int

      Current value of the digital interrupt of a robot's board


.. py:class:: GeoPoint(*, latitude: float = ..., longitude: float = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: latitude
      :annotation: :float

      

   .. py:attribute:: longitude
      :annotation: :float

      


.. py:class:: GeometriesInFrame(*, reference_frame: Text = ..., geometries: Optional[Iterable[global___Geometry]] = ...)



   GeometriesinFrame contains the dimensions of a given geometry, pose of its center point, and the reference frame by which it was
   observed.

   .. py:attribute:: reference_frame
      :annotation: :Text

      Reference frame of the observer of the geometry

   .. py:method:: geometries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]
      :property:

      Dimensional type



.. py:class:: Geometry(*, center: Optional[global___Pose] = ..., sphere: Optional[global___Sphere] = ..., box: Optional[global___RectangularPrism] = ...)



   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.

   .. py:method:: center(self) -> global___Pose
      :property:

      Pose of a gemetries center point


   .. py:method:: sphere(self) -> global___Sphere
      :property:


   .. py:method:: box(self) -> global___RectangularPrism
      :property:


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[box, b'box', center, b'center', geometry_type, b'geometry_type', sphere, b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(self, oneof_group: typing_extensions.Literal[geometry_type, b'geometry_type']) -> Optional[typing_extensions.Literal[sphere, box]]

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: PointCloudObject(*, point_cloud: bytes = ..., geometries: Optional[global___GeometriesInFrame] = ...)



   PointCloudObject contains an image in bytes with point cloud data of all of the objects captured by a given observer as well as a
   repeated list of geometries which respresents the center point and geometry of each of the objects within the point cloud

   .. py:attribute:: point_cloud
      :annotation: :bytes

      image frame expressed in bytes

   .. py:method:: geometries(self) -> global___GeometriesInFrame
      :property:

      volume of a given geometry


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[geometries, b'geometries']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Pose(*, x: float = ..., y: float = ..., z: float = ..., o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)



   Pose is a combination of location and orientation.
   Location is expressed as distance which is represented by x , y, z coordinates. Orientation is expressed as an orientation vector which
   is represented by o_x, o_y, o_z and theta. The o_x, o_y, o_z coordinates represent the point on the cartesian unit sphere that the end of
   the arm is pointing to (with the origin as reference). That unit vector forms an axis around which theta rotates. This means that
   incrementing / decrementing theta will perform an inline rotation of the end effector.
   Theta is defined as rotation between two planes: the first being defined by the origin, the point (0,0,1), and the rx, ry, rz point, and the
   second being defined by the origin, the rx, ry, rz point and the local Z axis. Therefore, if theta is kept at zero as the north/south pole
   is circled, the Roll will correct itself to remain in-line.

   .. py:attribute:: x
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: y
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: z
      :annotation: :float

      millimeters from the origin

   .. py:attribute:: o_x
      :annotation: :float

      z component of a vector defining axis of rotation

   .. py:attribute:: o_y
      :annotation: :float

      x component of a vector defining axis of rotation

   .. py:attribute:: o_z
      :annotation: :float

      y component of a vector defining axis of rotation

   .. py:attribute:: theta
      :annotation: :float

      degrees


.. py:class:: PoseInFrame(*, reference_frame: Text = ..., pose: Optional[global___Pose] = ...)



   PoseInFrame contains a pose and the and the reference frame in which it was observed

   .. py:attribute:: reference_frame
      :annotation: :Text

      

   .. py:method:: pose(self) -> global___Pose
      :property:


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[pose, b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RectangularPrism(*, width_mm: float = ..., length_mm: float = ..., depth_mm: float = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: width_mm
      :annotation: :float

      

   .. py:attribute:: length_mm
      :annotation: :float

      

   .. py:attribute:: depth_mm
      :annotation: :float

      


.. py:class:: ResourceName(*, namespace: Text = ..., type: Text = ..., subtype: Text = ..., name: Text = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: namespace
      :annotation: :Text

      

   .. py:attribute:: type
      :annotation: :Text

      

   .. py:attribute:: subtype
      :annotation: :Text

      

   .. py:attribute:: name
      :annotation: :Text

      


.. py:class:: Sphere(*, radius_mm: float = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: radius_mm
      :annotation: :float

      


.. py:class:: Transform(*, reference_frame: Text = ..., pose_in_observer_frame: Optional[global___PoseInFrame] = ...)



   Transform contains a pose and two reference frames. The first reference frame is the starting reference frame, and the second reference
   frame is the observer reference frame. The second reference frame has a pose which represents the pose of an object in the first
   reference frame as observed within the second reference frame.

   .. py:attribute:: reference_frame
      :annotation: :Text

      the name of a given reference frame

   .. py:method:: pose_in_observer_frame(self) -> global___PoseInFrame
      :property:

      the pose of the above reference frame with respect to a different observer reference frame


   .. py:method:: HasField(self, field_name: typing_extensions.Literal[pose_in_observer_frame, b'pose_in_observer_frame']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Vector3(*, x: float = ..., y: float = ..., z: float = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: x
      :annotation: :float

      

   .. py:attribute:: y
      :annotation: :float

      

   .. py:attribute:: z
      :annotation: :float

      


.. py:class:: WorldState(*, obstacles: Optional[Iterable[global___GeometriesInFrame]] = ..., transforms: Optional[Iterable[global___Transform]] = ...)



   WorldState contains information about the physical environment around a given robot. All of the fields within this message are optional,
   they can include information about the physical dimensions of an obstacle, the freespace of a robot, and any desired transforms between a
   given reference frame and a new target reference frame.

   .. py:method:: obstacles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GeometriesInFrame]
      :property:

      a list of obstacles expressed as a geomtry and the reference frame in which it was observed; this field is optional


   .. py:method:: transforms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Transform]
      :property:

      a list of Transforms needed to transform a pose from one reference frame to another; this field is optional



