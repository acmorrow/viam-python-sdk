:py:mod:`viam.proto.api.component.arm`
======================================

.. py:module:: viam.proto.api.component.arm

.. autoapi-nested-parse::

   @generated by Viam.
   Do not edit manually!



Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.proto.api.component.arm.ArmServiceBase
   viam.proto.api.component.arm.ArmServiceStub
   viam.proto.api.component.arm.GetEndPositionRequest
   viam.proto.api.component.arm.GetEndPositionResponse
   viam.proto.api.component.arm.GetJointPositionsRequest
   viam.proto.api.component.arm.GetJointPositionsResponse
   viam.proto.api.component.arm.JointPositions
   viam.proto.api.component.arm.MoveToJointPositionsRequest
   viam.proto.api.component.arm.MoveToJointPositionsResponse
   viam.proto.api.component.arm.MoveToPositionRequest
   viam.proto.api.component.arm.MoveToPositionResponse
   viam.proto.api.component.arm.Status
   viam.proto.api.component.arm.StopRequest
   viam.proto.api.component.arm.StopResponse




.. py:class:: ArmServiceBase



   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: GetEndPosition(stream: grpclib.server.Stream[proto.api.component.arm.v1.arm_pb2.GetEndPositionRequest, proto.api.component.arm.v1.arm_pb2.GetEndPositionResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: MoveToPosition(stream: grpclib.server.Stream[proto.api.component.arm.v1.arm_pb2.MoveToPositionRequest, proto.api.component.arm.v1.arm_pb2.MoveToPositionResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: GetJointPositions(stream: grpclib.server.Stream[proto.api.component.arm.v1.arm_pb2.GetJointPositionsRequest, proto.api.component.arm.v1.arm_pb2.GetJointPositionsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: MoveToJointPositions(stream: grpclib.server.Stream[proto.api.component.arm.v1.arm_pb2.MoveToJointPositionsRequest, proto.api.component.arm.v1.arm_pb2.MoveToJointPositionsResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: Stop(stream: grpclib.server.Stream[proto.api.component.arm.v1.arm_pb2.StopRequest, proto.api.component.arm.v1.arm_pb2.StopResponse]) -> None
      :abstractmethod:
      :async:


   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]



.. py:class:: ArmServiceStub(channel: grpclib.client.Channel)


.. py:class:: GetEndPositionRequest(*, name: Text = ..., extra: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      Name of an arm

   .. py:method:: extra() -> google.protobuf.struct_pb2.Struct
      :property:

      Additional arguments to the method


   .. py:method:: HasField(field_name: typing_extensions.Literal[extra, b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetEndPositionResponse(*, pose: Optional[viam.gen.proto.api.common.v1.common_pb2.Pose] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: pose() -> viam.gen.proto.api.common.v1.common_pb2.Pose
      :property:

      Returns 6d pose of the end effector relative to the base, represented by X,Y,Z coordinates which express
      millimeters and theta, ox, oy, oz coordinates which express an orientation vector


   .. py:method:: HasField(field_name: typing_extensions.Literal[pose, b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetJointPositionsRequest(*, name: Text = ..., extra: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      Name of an arm

   .. py:method:: extra() -> google.protobuf.struct_pb2.Struct
      :property:

      Additional arguments to the method


   .. py:method:: HasField(field_name: typing_extensions.Literal[extra, b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetJointPositionsResponse(*, positions: Optional[global___JointPositions] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: positions() -> global___JointPositions
      :property:

      a list JointPositions


   .. py:method:: HasField(field_name: typing_extensions.Literal[positions, b'positions']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: JointPositions(*, values: Optional[Iterable[float]] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:method:: values() -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[float]
      :property:

      A list of joint positions. Rotations values are in degrees, translational values in mm.
      The numbers are ordered spatially from the base toward the end effector
      This is used in GetJointPositionsResponse and MoveToJointPositionsRequest



.. py:class:: MoveToJointPositionsRequest(*, name: Text = ..., positions: Optional[global___JointPositions] = ..., extra: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      Name of an arm

   .. py:method:: positions() -> global___JointPositions
      :property:

      A list of joint positions
      There should be 1 entry in the list per joint DOF, ordered spatially from the base toward the end effector


   .. py:method:: extra() -> google.protobuf.struct_pb2.Struct
      :property:

      Additional arguments to the method


   .. py:method:: HasField(field_name: typing_extensions.Literal[extra, b'extra', positions, b'positions']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: MoveToJointPositionsResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: MoveToPositionRequest(*, name: Text = ..., to: Optional[viam.gen.proto.api.common.v1.common_pb2.Pose] = ..., world_state: Optional[viam.gen.proto.api.common.v1.common_pb2.WorldState] = ..., extra: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      Name of an arm

   .. py:method:: to() -> viam.gen.proto.api.common.v1.common_pb2.Pose
      :property:


   .. py:method:: world_state() -> viam.gen.proto.api.common.v1.common_pb2.WorldState
      :property:


   .. py:method:: extra() -> google.protobuf.struct_pb2.Struct
      :property:

      Additional arguments to the method


   .. py:method:: HasField(field_name: typing_extensions.Literal[_world_state, b'_world_state', extra, b'extra', to, b'to', world_state, b'world_state']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: typing_extensions.Literal[_world_state, b'_world_state']) -> Optional[typing_extensions.Literal[world_state]]

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MoveToPositionResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: Status(*, end_position: Optional[viam.gen.proto.api.common.v1.common_pb2.Pose] = ..., joint_positions: Optional[global___JointPositions] = ..., is_moving: bool = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: is_moving
      :annotation: :bool

      

   .. py:method:: end_position() -> viam.gen.proto.api.common.v1.common_pb2.Pose
      :property:


   .. py:method:: joint_positions() -> global___JointPositions
      :property:


   .. py:method:: HasField(field_name: typing_extensions.Literal[end_position, b'end_position', joint_positions, b'joint_positions']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StopRequest(*, name: Text = ..., extra: Optional[google.protobuf.struct_pb2.Struct] = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: name
      :annotation: :Text

      Name of an arm

   .. py:method:: extra() -> google.protobuf.struct_pb2.Struct
      :property:

      Additional arguments to the method


   .. py:method:: HasField(field_name: typing_extensions.Literal[extra, b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StopResponse



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


